generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(uuid())
  name      String
  email     String   @unique
  password  String
  avatarUrl String?  @map("avatar_url")
  phone     String?  @map("phone")
  address   String?  @map("address")
  isBlocked Boolean  @default(false) @map("is_blocked")
  isAdmin   Boolean  @default(false) @map("is_admin")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  messages    Message[]
  memberships GroupMember[]
  reads       MessageRead[]

  // Back-relations para DMs
  directThreadsA DirectThread[] @relation("DirectUserA")
  directThreadsB DirectThread[] @relation("DirectUserB")

  // Meetings
  hostedMeetings Meeting[]
  meetingGuests  MeetingParticipant[]

  // Telefonia SIP (um por usuário)
  sipAccount SipAccount?

  // Campo inverso para MessageFavorite
  favorites MessageFavorite[]
}

model Group {
  id        String   @id @default(uuid())
  name      String
  isPrivate Boolean  @default(false) @map("is_private")
  createdAt DateTime @default(now()) @map("created_at")

  members  GroupMember[]
  messages Message[]

  directThread DirectThread?
}

model GroupMember {
  id       String   @id @default(uuid())
  group    Group    @relation(fields: [groupId], references: [id])
  groupId  String   @map("group_id")
  user     User     @relation(fields: [userId], references: [id])
  userId   String   @map("user_id")
  role     String   @default("member")
  joinedAt DateTime @default(now()) @map("joined_at")

  @@unique([groupId, userId])
  @@index([userId])
}

enum MessageType {
  text
  image
  audio
  sticker
  gif
}

model Message {
  id        String      @id @default(uuid())
  group     Group       @relation(fields: [groupId], references: [id])
  groupId   String      @map("group_id")
  author    User        @relation(fields: [authorId], references: [id])
  authorId  String      @map("author_id")
  type      MessageType @default(text)
  content   String // text or URL/path
  createdAt DateTime    @default(now()) @map("created_at")
  editedAt  DateTime?   @map("edited_at")
  deletedAt DateTime?   @map("deleted_at")

  reads MessageRead[]

  // Reply-to self relation
  replyTo   Message?  @relation("MessageReply", fields: [replyToId], references: [id])
  replyToId String?   @map("reply_to_id")
  replies   Message[] @relation("MessageReply")

  // Campo inverso para MessageFavorite
  favorites MessageFavorite[]

  @@index([groupId, createdAt])
}

model MessageRead {
  id        String   @id @default(uuid())
  message   Message  @relation(fields: [messageId], references: [id])
  messageId String   @map("message_id")
  user      User     @relation(fields: [userId], references: [id])
  userId    String   @map("user_id")
  readAt    DateTime @default(now()) @map("read_at")

  @@unique([messageId, userId])
  @@index([userId])
}

model MessageFavorite {
  id        String   @id @default(uuid())
  message   Message  @relation(fields: [messageId], references: [id])
  messageId String   @map("message_id")
  user      User     @relation(fields: [userId], references: [id])
  userId    String   @map("user_id")
  createdAt DateTime @default(now()) @map("created_at")

  @@unique([messageId, userId])
  @@index([userId])
}

// Conversas diretas (1:1) representam um grupo privado com exatamente 2 membros
model DirectThread {
  id        String   @id @default(uuid())
  group     Group    @relation(fields: [groupId], references: [id])
  groupId   String   @unique @map("group_id")
  userA     User     @relation("DirectUserA", fields: [userAId], references: [id])
  userAId   String   @map("user_a_id")
  userB     User     @relation("DirectUserB", fields: [userBId], references: [id])
  userBId   String   @map("user_b_id")
  createdAt DateTime @default(now()) @map("created_at")

  @@unique([userAId, userBId])
  @@index([userAId])
  @@index([userBId])
}

// Conta SIP por usuário (telefonia)
model SipAccount {
  id        String   @id @default(uuid())
  user      User     @relation(fields: [userId], references: [id])
  userId    String   @unique @map("user_id")
  domain    String   @map("domain")
  extension String   @map("extension")
  password  String   @map("password")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // App-level registration heartbeat (not PBX authoritative)
  regRegistered Boolean   @default(false) @map("reg_registered")
  regStatus     String?   @map("reg_status")
  regUpdatedAt  DateTime? @map("reg_updated_at")

  @@index([domain])
  @@index([extension])
}

// Video meetings (instant or scheduled)
model Meeting {
  id             String    @id @default(uuid())
  code           String    @unique
  title          String
  description    String?
  host           User      @relation(fields: [hostId], references: [id])
  hostId         String    @map("host_id")
  isInstant      Boolean   @default(false) @map("is_instant")
  scheduledStart DateTime? @map("scheduled_start")
  scheduledEnd   DateTime? @map("scheduled_end")
  createdAt      DateTime  @default(now()) @map("created_at")
  updatedAt      DateTime  @updatedAt @map("updated_at")

  participants MeetingParticipant[]
}

model MeetingParticipant {
  id          String   @id @default(uuid())
  meeting     Meeting  @relation(fields: [meetingId], references: [id])
  meetingId   String   @map("meeting_id")
  user        User?    @relation(fields: [userId], references: [id])
  userId      String?  @map("user_id")
  email       String?
  name        String?
  role        String   @default("guest")
  status      String   @default("invited")
  inviteToken String?  @unique @map("invite_token")
  createdAt   DateTime @default(now()) @map("created_at")

  @@index([meetingId])
  @@index([userId])
}
